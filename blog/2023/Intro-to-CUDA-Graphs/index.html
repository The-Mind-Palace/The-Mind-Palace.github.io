<!DOCTYPE html>
<html lang="en">

  <!-- Head -->
  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">    <!-- Metadata, OpenGraph and Schema.org -->
    

    <!-- Standard metadata -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>What are CUDA Graphs? | Ramya  Prabhu</title>
    <meta name="author" content="Ramya  Prabhu">
    <meta name="description" content="What are CUDA Graphs? Some things I learnt and some resources I loved">
    <meta name="keywords" content="systems, optimization, systems for ML">


    <!-- Bootstrap & MDB -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">

    <!-- Bootstrap Table -->
    <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css">

    <!-- Fonts & Icons -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.15.4/css/all.min.css" integrity="sha256-mUZM63G8m73Mcidfrv5E+Y61y7a12O5mW4ezU3bxqW4=" crossorigin="anonymous">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous">
    <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

    <!-- Code Syntax Highlighting -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light">

    

    <!-- Styles -->
    
    <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%8F%B0&lt;/text&gt;&lt;/svg&gt;">
    
    <link rel="stylesheet" href="/assets/css/main.css">
    <link rel="canonical" href="https://the-mind-palace.github.io//blog/2023/Intro-to-CUDA-Graphs/">

    <!-- Dark Mode -->
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark">

    <script src="/assets/js/theme.js"></script>
    <script src="/assets/js/dark_mode.js"></script>
    

  </head>

  <!-- Body -->
  <body class="fixed-top-nav ">

    <!-- Header -->
    <header>

      <!-- Nav Bar -->
      <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
        <div class="container">
          <a class="navbar-brand title font-weight-lighter" href="/"><!-- <span class="font-weight-bold">Ramya&nbsp;</span> --><!--Prabhu--></a>
          <!-- Navbar Toggle -->
          <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar top-bar"></span>
            <span class="icon-bar middle-bar"></span>
            <span class="icon-bar bottom-bar"></span>
          </button>

          <div class="collapse navbar-collapse text-right" id="navbarNav">
            <ul class="navbar-nav ml-auto flex-nowrap">

              <!-- About -->
              <li class="nav-item ">
                <a class="nav-link" href="/">About</a>
              </li>
              

              <!-- Other pages -->
              <li class="nav-item ">
                <a class="nav-link" href="/repositories/"></a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/publications/">Publications</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/projects/">Projects</a>
              </li>
              <li class="nav-item ">
                <a class="nav-link" href="/cv/">cv</a>
              </li>

              <!-- Blog -->
              <li class="nav-item active">
                <a class="nav-link" href="/blog/">blog<span class="sr-only">(current)</span></a>
              </li>

              <!-- Toogle theme mode -->
              <li class="toggle-container">
                <button id="light-toggle" title="Change theme">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
                </button>
              </li>
            </ul>
          </div>
        </div>
      </nav>

      <!-- Scrolling Progress Bar -->
      <progress id="progress" value="0">
        <div class="progress-container">
          <span class="progress-bar"></span>
        </div>
      </progress>
    </header>


    <!-- Content -->
    <div class="container mt-5">
      
        <!-- _layouts/post.html -->

<div class="post">

  <header class="post-header">
    <h1 class="post-title">What are CUDA Graphs?</h1>
    <p class="post-meta">October 24, 2023</p>
    <p class="post-tags">
      <a href="/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>
        ·  
        <a href="/blog/category/systems-for-ml">
          <i class="fas fa-tag fa-sm"></i> systems-for-ml</a>  
          

    </p>
  </header>

  <article class="post-content">
    
    <div id="markdown-content">
      <p>With advancements in GPU hardware and software, CPU overhead in launching CUDA kernels is beginning to become a bottleneck. This is especially observed in many HPC applications as deep neural network training and scientific simulations. Workloads using Python instead of C++ also experience this bottleneck [compared to C++, Python is 5x slower].</p>

<p>And while there are a few solutions to this bottleneck, this post is about CUDA Graphs.</p>

<p><b> Table of Contents </b></p>

<h2 id="why-do-i-need-this">Why do I need this?</h2>

<p>For GPU kernels with short runtimes, CPU Launch time becomes an overhead. Separating out the definition of a graph from its execution reduces CPU kernel launch costs and can make a significant performance difference in such cases.</p>

<p>One can obviously make the case that this overhead can perhaps be removed by overlaping the launch of the kernel with the execution of another independent kernal. And while this is true, the overhead still exists, associated to multiple launches, as they would still require a separate launch operation for each kernel, where each is oblivious to the presence of the others.</p>

<p>Another means of solving this problem is to write fused kernels, but that is cumbersome.</p>

<p>CUDA Graphs have been designed to allow work to be defined as graphs rather than single operations. They address the above issue by providing a mechanism to launch multiple GPU operations through a single CPU operation, and hence reduce overheads</p>

<p><img src="../images/image_2_intro_to_CUDA.png" alt=""></p>

<p>Graphs also enable the CUDA driver to perform a number of optimizations because the whole workflow is visible, including execution, data movement, and synchronization interactions, improving execution performance in a variety of cases (depending on the workload).</p>

<h2 id="what-is-this">What is this?</h2>

<p>CUDA Graphs give you a new manner of submitting your kernels using cuda.</p>

<p>CUDA operations form the nodes of a graph, with the edges being the dependencies between the operations. All CUDA work essentially forms a graph. This is realised by this data  abstraction.</p>

<p><img src="../images/image_1_intro_to_CUDA.png" alt="Fig: How CUDA Graphs are able to capture the workstreams' workflow"></p>

<p>&lt;p style=”text-align: center;”Fig 2: How CUDA Graphs are able to capture the workstreams’ workflow*&lt;/p&gt;</p>

<p>The operations in the nodes can be:</p>

<ul>
  <li>
<strong>Kernel Launches</strong> :  <em>CUDA kernel running on GPU</em>
</li>
  <li>
<strong>CPU FUNCTION CALLS</strong> :  <em>Callback function on CPU</em>
</li>
  <li>
<strong>Memcopy/Memset</strong> :  <em>GPU data management</em>
</li>
  <li>
<strong>Memory Alloc/Free</strong> :  <em>Inline memory allocation</em>
</li>
  <li>
<strong>Sub-Graph</strong> :  <em>Graphs are hierarchical</em>
</li>
  <li><strong>empty node</strong></li>
  <li><strong>waiting on an event</strong></li>
  <li><strong>recording an event</strong></li>
  <li><strong>signalling an external semaphore</strong></li>
  <li><strong>waiting on an external semaphore</strong></li>
  <li><strong>conditional node</strong></li>
</ul>

<p>CUDA 12.3 introduced edge data on CUDA Graphs. Edge data modifies a dependency specified by an edge and consists of three parts: an outgoing port, an incoming port, and a type. An outgoing port specifies when an associated edge is triggered. An incoming port specifies what portion of a node is dependent on an associated edge. A type modifies the relation between the endpoints.</p>

<p>Port values are specific to node type and direction, and edge types may be restricted to specific node types. In all cases, zero-initialized edge data represents default behavior. Outgoing port 0 waits on an entire task, incoming port 0 blocks an entire task, and edge type 0 is associated with a full dependency with memory synchronizing behavior.</p>

<h2 id="how-do-i-use-this">How do I use this?</h2>

<p>To use CUDA Graphs:</p>

<ul>
  <li>
    <p><strong>Define a graph</strong> [<em>created in host code, Loaded from disk or built from libraries</em>]:</p>

    <p>During the definition phase, a program creates a description of the operations in the graph along with the dependencies between them.</p>
  </li>
  <li>
    <p><strong>Instantiate the graph</strong> [<em>Snapshot of template, Sets up &amp; initializes GPU execution structures, (create once, run many times)</em>]</p>

    <p>Instantiation takes a snapshot of the graph template, validates it, and performs much of the setup and initialization of work with the aim of minimizing what needs to be done at launch. The resulting instance is known as an executable graph.</p>
  </li>
  <li>
    <p><strong>Execute it</strong></p>

    <p>An executable graph may be launched into a stream, similar to any other CUDA work. It may be launched any number of times without repeating the instantiation.</p>
  </li>
</ul>

<p><img src="../images/image_3_intro_to_CUDA.png" alt=""></p>

<p>A graph can be defined by either using StreamCapture mechanism or by defining the nodes and dependencies explicitly through newly available API calls. The Graphs may also span multiple GPUs.</p>

<p>Stream capture records asynchronous operations without actually launching a kernel. It follows inter-stream
dependencies to create forks &amp; joins. It can be used to construct a graph from normal CUDA stream syntax. It captures calls to external libraries. But if a library calls cudaStreamSynchronize() or any other synchronous operation, stream capture runs into a prolem. Since capture isn’t launching anything, synchronize cannot wait for anything and therefore capture fails.</p>

<p>The way around this is to explicitly create the graph using Graph APIs provided by CUDA or to create the graph using stream capture and then capture the library related node using the Graph API.</p>

<p><img src="../images/image_4_intro_to_CUDA.png" alt=""></p>

<p>Graphs can be generated once and executed repeatedly. Data management may be optimized transparently through prefetching, read duplication, subdivision to finer granularity. Since Graphs capture cross-device dependencies, it can be used to optimise multi-device dependencies.
In situations where the workflow is not changing, the overhead of definition and instantiation can be amortized over many executions, and graphs provide a clear advantage over streams.</p>

<h3 id="updation-of-graphs">Updation of Graphs</h3>

<p>In situations where the workflow changes the graph becomes out of date and must be modified. Major changes to graph structure such as topology or types of nodes will require re-instantiation of the source graph because various topology-related optimization techniques must be re-applied.</p>

<p>The cost of repeated instantiation can reduce the overall performance benefit from graph execution, but it is common for only node parameters, such as kernel parameters and cudaMemcpy addresses, to change while graph topology remains the same.[ <strong>So topology can’t be updated :( . You have to redo the graph</strong>] For this case, CUDA provides a lightweight mechanism known as “Graph Update,” which allows certain node parameters to be modified in-place without having to rebuild the entire graph. This is much more efficient than re-instantiation.</p>

<p>CUDA also provides a mechanism for enabling and disabling individual nodes without affecting their current parameters.</p>

<p>CUDA provides two mechanisms for updating instantiated graph parameters, whole graph update and individual node update. Whole graph update allows the user to supply a topologically identical cudaGraph_t object whose nodes contain updated parameters. Individual node update allows the user to explicitly update the parameters of individual nodes. Using an updated cudaGraph_t is more convenient when a large number of nodes are being updated, or when the graph topology is unknown to the caller (i.e., The graph resulted from stream capture of a library call). Using individual node update is preferred when the number of changes is small and the user has the handles to the nodes requiring updates. Individual node update skips the topology checks and comparisons for unchanged nodes, so it can be more efficient in many cases.</p>

<p>However, there are some limitations to how certain graph nodes can and cannot be updated. For more details, please check out <a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#cuda-graphs" rel="external nofollow noopener" target="_blank">this link</a>, it is a fantastice resource.</p>

<h2 id="device-graph-requirements">Device Graph Requirements</h2>

<p><strong>General requirements:</strong></p>

<ul>
  <li>The graph’s nodes must all reside on a single device.</li>
  <li>The graph can only contain kernel nodes, memcpy nodes, memset nodes, and child graph nodes.</li>
</ul>

<p><strong>Kernel nodes:</strong></p>

<ul>
  <li>Use of CUDA Dynamic Parallelism by kernels in the graph is not permitted.</li>
  <li>Cooperative launches are permitted so long as MPS is not in use.</li>
</ul>

<p><strong>Memcpy nodes:</strong></p>

<ul>
  <li>Only copies involving device memory and/or pinned device-mapped host memory are permitted.</li>
  <li>Copies involving CUDA arrays are not permitted.</li>
</ul>

<h2 id="nccl-support-for-cuda-graphs">NCCL SUPPORT FOR CUDA GRAPHS</h2>

<p>Recent releases have seen the adoption of CUDA Graphs for NCCL calls. NCCL enables GPU-based collective and P2P communications.</p>

<p>For distributed multi-GPU workloads, NCCL is used for collective communications. If we look at training a neural network that leverages data parallelism, without NCCL support for CUDA graphs, we’ll need a separate launch for each of forward/back propagation and NCCL AllReduce. By contrast, with NCCL support for CUDA graphs, we can reduce launch overhead by lumping together the forward/backward propagation and NCCL AllReduce all in a single graph launch. Starting with NCCL 2.11, when NCCL communication is captured and the CollNet algorithm is used, NCCL allows for further performance improvement via user buffer registration.</p>

<p>Having multiple outstanding NCCL operations that are any combination of graph-captured or non-captured is supported. There is a caveat that the mechanism NCCL uses internally to accomplish this has been seen to cause CUDA to deadlock when the graphs of multiple communicators are cudaGraphLaunch()’d from the same thread</p>

<p><img src="../images/image_5_intro_to_CUDA.png" alt="Alt text"></p>

<h2 id="pytorch--cuda-graphs">PyTorch + CUDA Graphs</h2>

<p>PyTorch announced its adoption of CUDA Graph into advanced features to accelerate DL features.</p>

<p>PyTorch supports the construction of CUDA graphs using stream capture, which puts a CUDA stream in capture mode. CUDA work issued to a capturing stream doesn’t actually run on the GPU. Instead, the work is recorded in a graph. After capture, the graph can be launched to run the GPU work as many times as needed.</p>

<p>Each replay runs the same kernels with the same arguments. For pointer arguments this means the same memory addresses are used. By filling input memory with new data (e.g., from a new batch) before each replay, you can rerun the same work on new data.</p>

<p>A graph’s arguments and kernels are fixed, so a graph replay skips all layers of argument setup and kernel dispatch, including Python, C++, and CUDA driver overheads. Under the hood, a replay submits the entire graph’s work to the GPU with a single call to cudaGraphLaunch. Kernels in a replay also execute slightly faster on the GPU, but eliding CPU overhead is the main benefit.</p>

<p><strong>Constraints</strong></p>

<p>A set of ops is capturable if it doesn’t violate any of the following constraints:</p>

<ul>
  <li>Capture must occur on a non-default stream.</li>
  <li>Ops that synchronize the CPU with the GPU (e.g., .item() calls) are prohibited.</li>
  <li>CUDA RNG ops are allowed, but must use default generators. For example, explicitly constructing a new torch.Generator instance and passing it as the generator argument to an RNG function is prohibited.</li>
</ul>

<p><em>Violating any of the above will likely cause a runtime error</em></p>

<ul>
  <li>Within a process, only one capture may be underway at a time.</li>
  <li>No non-captured CUDA work may run in this process (on any thread) while capture is underway.</li>
  <li>CPU work is not captured. If the captured ops include CPU work, that work will be elided during replay.</li>
  <li>Every replay reads from and writes to the same (virtual) memory addresses.</li>
  <li>Dynamic control flow (based on CPU or GPU data) is prohibited.</li>
  <li>Dynamic shapes are prohibited. The graph assumes every tensor in the captured op sequence has the same size and layout in every replay.</li>
  <li>Using multiple streams in a capture is allowed, but there are restrictions.</li>
</ul>

<p><em>Violating any of the above will likely cause silent numerical errors or undefined behavior</em></p>

<p><strong>Non-constraints</strong></p>

<p>Once captured, the graph may be replayed on any stream.</p>

<h3 id="some-interesting-resources">Some interesting resources</h3>

<ul>
  <li>https://github.com/olcf/cuda-training-series/blob/master/exercises/hw13/README.md</li>
  <li>https://www.nvidia.com/en-us/on-demand/session/gtcspring21-s32082/</li>
  <li>https://github.com/NVIDIA/cuda-samples/tree/master/Samples/3_CUDA_Features/simpleCudaGraphs</li>
</ul>

<h2 id="references">References</h2>

<p>[1]  https://developer.nvidia.com/blog/cuda-10-features-revealed/</p>

<p>[2]  https://developer.nvidia.com/blog/cuda-graphs/</p>

<p>[3]  https://www.olcf.ornl.gov/wp-content/uploads/2021/10/013_CUDA_Graphs.pdf</p>

<p>[4]  https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#graph-structure</p>

<p>[5]  https://docs.nvidia.com/deeplearning/nccl/user-guide/docs/usage/cudagraph.html</p>

<p>[6]  https://pytorch.org/blog/accelerating-pytorch-with-cuda-graphs/</p>

<p>[7] https://pytorch.org/docs/master/notes/cuda.html#cuda-graphs</p>

    </div>
  </article>
</div>

      
    </div>

    <!-- Footer -->    
    <footer class="fixed-bottom">
      <div class="container mt-0">
        © Copyright 2024 Ramya  Prabhu. Last updated: November 19, 2024.
      </div>
    </footer>

    <!-- JavaScripts -->
    <!-- jQuery -->
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>

    <!-- Bootsrap & MDB scripts -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>

    <!-- Masonry & imagesLoaded -->
  <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
  <script defer src="/assets/js/masonry.js" type="text/javascript"></script>
    
  <!-- Medium Zoom JS -->
  <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script>
  <script defer src="/assets/js/zoom.js"></script>

  <!-- Bootstrap Table -->
  <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script>

  <!-- Load Common JS -->
  <script src="/assets/js/no_defer.js"></script>
  <script defer src="/assets/js/common.js"></script>
  <script defer src="/assets/js/copy_code.js" type="text/javascript"></script>

    
  <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
  <script async src="https://badge.dimensions.ai/badge.js"></script>

    <!-- MathJax -->
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        tags: 'ams'
      }
    };
  </script>
  <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script>
  <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>

    
    

<!-- Scrolling Progress Bar -->
<script type="text/javascript">
  /*
   * This JavaScript code has been adapted from the article 
   * https://css-tricks.com/reading-position-indicator/ authored by Pankaj Parashar, 
   * published on the website https://css-tricks.com on the 7th of May, 2014.
   * Couple of changes were made to the original code to make it compatible 
   * with the `al-foio` theme.
   */
  const progressBar = $("#progress");
  /*
   * We set up the bar after all elements are done loading.
   * In some cases, if the images in the page are larger than the intended
   * size they'll have on the page, they'll be resized via CSS to accomodate
   * the desired size. This mistake, however, breaks the computations as the
   * scroll size is computed as soon as the elements finish loading.
   * To account for this, a minimal delay was introduced before computing the
   * values.
   */
  window.onload = function () {
    setTimeout(progressBarSetup, 50);
  };
  /*
   * We set up the bar according to the browser.
   * If the browser supports the progress element we use that.
   * Otherwise, we resize the bar thru CSS styling
   */
  function progressBarSetup() {
    if ("max" in document.createElement("progress")) {
      initializeProgressElement();
      $(document).on("scroll", function() {
        progressBar.attr({ value: getCurrentScrollPosition() });
      });
      $(window).on("resize", initializeProgressElement);
    } else {
      resizeProgressBar();
      $(document).on("scroll", resizeProgressBar);
      $(window).on("resize", resizeProgressBar);
    }
  }
  /*
   * The vertical scroll position is the same as the number of pixels that
   * are hidden from view above the scrollable area. Thus, a value > 0 is
   * how much the user has scrolled from the top
   */
  function getCurrentScrollPosition() {
    return $(window).scrollTop();
  }

  function initializeProgressElement() {
    let navbarHeight = $("#navbar").outerHeight(true);
    $("body").css({ "padding-top": navbarHeight });
    $("progress-container").css({ "padding-top": navbarHeight });
    progressBar.css({ top: navbarHeight });
    progressBar.attr({
      max: getDistanceToScroll(),
      value: getCurrentScrollPosition(),
    });
  }
  /*
   * The offset between the html document height and the browser viewport
   * height will be greater than zero if vertical scroll is possible.
   * This is the distance the user can scroll
   */
  function getDistanceToScroll() {
    return $(document).height() - $(window).height();
  }

  function resizeProgressBar() {
    progressBar.css({ width: getWidthPercentage() + "%" });
  }
  // The scroll ratio equals the percentage to resize the bar
  function getWidthPercentage() {
    return (getCurrentScrollPosition() / getDistanceToScroll()) * 100;
  }
</script>

  </body>
</html>
